---
layout: posts
title: Android and iPhones and Web, oh my
author: Tom Ball
category: blog
tags: j2objc android iphone ios testing
---

It's regularly asked why [J2ObjC purposely avoids translating UI code](http://j2objc.org/index.html#What_J2ObjC_isn't); after all, wouldn't it be wonderful if a tool existed where a developer can drop in Android source and out pops an iOS app? Our usual response is that world-class apps need user interfaces that are tightly integrated with each platform, and that common-denominator attempts to span platforms provide degrades user experiences. As I found when working on [Swing](http://en.wikipedia.org/wiki/Swing_(Java)) many years ago, customers notice the smallest deviations from a platform's UI standards and generally find them off-putting. But non-compromising UIs are just one of the reasons we focus on translating shared logic.

 The pressure for platform-independent apps is due to the cost and effort to create separate versions for each platform. This is especially true for the non-UI parts of the app, where the logic is identical but must be rewritten in different languages for Android, iOS, and browsers. Software development is expensive, and this sort of redundancy is wasteful, risky, and perhaps most important to developers, mind-numbingly boring. The [Don’t Repeat Yourself](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle is very applicable when building apps for multiple platforms.

 Additionally, there are hidden costs due to differences between an app on different platforms: missing functionality, unique bugs, etc. Your marketing people will (should) argue that this weakens the app's brand; in other words, its reputation among its current and potential customers. When an app behaves differently on different platforms, it’s often perceived as being lower-quality than its competitors. 

 J2ObjC was created to help address the problems associated with independent releases, without sacrificing the requirement for world-class, platform-specific user experiences. It's goal is to provide a [GWT](http://www.gwtproject.org/)-like translator and runtime, so iOS apps can be designed to share as much Java code as possible without compromising best-of-breed user interface designs. The key word in the previous sentence is designed, because as software engineers know, reusability needs to be an important design goal and not just an afterthought.

 We’ve found that [test-driven development](http://googletesting.blogspot.com/2008/09/test-first-is-fun_08.html) really helps support code reuse, because there is a huge overlap between testable and portable code.  If code is hard to test, it's also likely to be difficult to use on other platforms; UI and networking code in particular are difficult to unit test easily. By writing tests as the design is being implemented, this difficulty encourages hard-to-test code to be isolated from more easily tested code. Often, the design can be improved to further isolate hard-to-test code and thereby increase sharing, such as using [dependency injection](http://en.wikipedia.org/wiki/Dependency_injection) or [mock objects](http://en.wikipedia.org/wiki/Mock_object) in tests. Software development is challenging enough without sticking to designs that create unnecessary work.

 We strongly encourage using [continuous integration](http://googletesting.blogspot.com/2011/06/testing-at-speed-and-scale-of-google.html) for apps on all platforms they target. When an app is written to share Java code using Android, GWT, and J2ObjC, any changes that are committed to that shared code cause it to be rebuilt for Android, translated to JavaScript by GWT for browsers, and translated to Objective-C by J2ObjC for iOS, and all unit tests executed. Any changes that break any of these builds can then be quickly fixed or rolled back. This infrastructure allows engineers to work together, regardless of their Android, web, or iOS experience; effectively it leverages their work, cutting in third the effort that three separate ports of an app would otherwise require. It also allows the team to assess the three platform builds as parts of a single product, with (for the app's core functionality) a single set of features and outstanding issues.

Hopefully this clarifies J2ObjC's objectives. It's why we consider it more of a compiler than a source translator, since the output that matters most is what winds up in each app build, not how pretty the intermediate Objective-C looks (though it's very useful to inspect generated code). It's why the [JUnit](http://junit.org/) and [Mockito](https://code.google.com/p/mockito/) libraries were added before many JRE classes. And it's why we open-sourced J2ObjC; the software engineering community developed all these best practices we rely on, and as community members it's important we help improve them further.