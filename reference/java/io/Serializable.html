---

title: Serializable - JRE Emulation

layout: api
---

















































<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta name="description" content="Javadoc API documentation for JRE Emulation." />

<link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico" />
<title>

  Serializable - JRE Emulation


| JRE Emulation

</title>
<script src="../../../assets/doclava-developer-docs.js" type="text/javascript"></script>

<script src="../../../assets/doclava-developer-reference.js" type="text/javascript"></script>

<noscript>
  <style type="text/css">
    html,body{overflow:auto;}
    #body-content{position:relative; top:0;}
    #doc-content{overflow:visible;border-left:3px solid #666;}
    #side-nav{padding:0;}
    #side-nav .toggle-list ul {display:block;}
    #resize-packages-nav{border-bottom:3px solid #666;}
  </style>
</noscript>
</head>



<div id="api-info-block">




<div class="api-level">
  


  
  

</div>
</div><!-- end api-info-block -->


<!-- ======== START OF CLASS DATA ======== -->

<div id="jd-header">
    public
    
    
    
    interface
<h1>Serializable</h1>



  
  
  


</div><!-- end header -->

<div id="naMessage"></div>

<div id="jd-content" class="api apilevel-">
<table class="jd-inheritance-table">


    <tr>
        
        <td colspan="1" class="jd-inheritance-class-cell">java.io.Serializable</td>
    </tr>
    

</table>







<div class="jd-descr">


<h2>Class Overview</h2>
<p>Marks classes that can be serialized by <code><a href="reference/java/io/ObjectOutputStream.html">ObjectOutputStream</a></code> and
 deserialized by <code><a href="reference/java/io/ObjectInputStream.html">ObjectInputStream</a></code>.

 <p><strong>Warning:</strong> this interface limits how its implementing
 classes can change in the future. By implementing <code>Serializable</code> you
 expose your flexible in-memory implementation details as a rigid binary
 representation. Simple code changes--like renaming private fields--are
 not safe when the changed class is serializable.

 <h3>The Serialized Form</h3>
 By default, the serialization mechanism encodes an object's class name, the
 names of its non-transient fields (including non-public fields), and the
 values of all of those fields. The output is an opaque sequence of bytes.
 Those bytes can be decoded into a new, equivalent instance as long as the
 decoder has compatible versions of the originating classes.

 <p>Changing the class name, field names or field types breaks serialization
 compatibility and complicates interoperability between old and new versions
 of the serializable class. Adding or removing fields also complicates
 serialization between versions of a class because it requires your code to
 cope with missing fields.

 <p>Every serializable class is assigned a version identifier called a <code>serialVersionUID</code>. By default, this identifier is computed by hashing the
 class declaration and its members. This identifier is included in the
 serialized form so that version conflicts can be detected during
 deserialization. If the local <code>serialVersionUID</code> differs from the
 <code>serialVersionUID</code> in the serialized data, deserialization will fail
 with an <code><a href="reference/java/io/InvalidClassException.html">InvalidClassException</a></code>.

 <p>You can avoid this failure by declaring an explicit <code>serialVersionUID</code>. Declaring an explicit <code>serialVersionUID</code> tells the
 serialization mechanism that the class is forward and backward compatible
 with all versions that share that <code>serialVersionUID</code>. Declaring a
 <code>serialVersionUID</code> looks like this: <pre>   <code>private static final long serialVersionUID = 0L;
 </code></pre>
 If you declare a <code>serialVersionUID</code>, you should increment it each
 time your class changes incompatibly with the previous version. Typically
 this is when you add, change or remove a non-transient field.

 <p>You can take control of your serialized form by implementing these two
 methods with these exact signatures in your serializable classes:
 <pre>   <code>private void writeObject(java.io.ObjectOutputStream out)
       throws IOException {
     // write 'this' to 'out'...
   </code>

   private void readObject(java.io.ObjectInputStream in)
       throws IOException, ClassNotFoundException {
     // populate the fields of 'this' from the data in 'in'...
   }
 }</pre>
 It is impossible to maintain serialization compatibility across a class name
 change. For this reason, implementing <code>Serializable</code> in anonymous
 inner classes is highly discouraged: simply reordering the members in the
 file could change the generated class name and break serialization
 compatibility.

 <p>You can exclude member fields from serialization by giving them the <code>transient</code> modifier. Upon deserialization, the transient field's value will
 be null, 0, or false according to its type.

 <h3>Implement Serializable Judiciously</h3>
 Refer to <i>Effective Java</i>'s chapter on serialization for thorough
 coverage of the serialization API. The book explains how to use this
 interface without harming your application's maintainability.

 <h3>Recommended Alternatives</h3>
 <strong>JSON</strong> is concise, human-readable and efficient. Android
 includes both a android.util.JsonReader streaming API and a <code><a href="reference/org/json/JSONObject.html">tree API</a></code> to read and write JSON. Use a binding library
 like <a href="http://code.google.com/p/google-gson/">GSON</a> to read and
 write Java objects directly.
</p>





</div><!-- jd-descr -->
















<div class="jd-descr">


</div><!-- jd-descr (summary) -->

<!-- Details -->








<!-- XML Attributes -->


<!-- Enum Values -->


<!-- Constants -->


<!-- Fields -->


<!-- Public ctors -->



<!-- ========= CONSTRUCTOR DETAIL ======== -->
<!-- Protected ctors -->



<!-- ========= METHOD DETAIL ======== -->
<!-- Public methdos -->



<!-- ========= METHOD DETAIL ======== -->



<!-- ========= END OF CLASS DATA ========= -->
<a id="navbar_top"></a>

</div> <!-- jd-content -->
<!-- end doc-content class -->
</div> <!-- end body-content --> 

<script type="text/javascript">
init(); /* initialize doclava-developer-docs.js */
</script>
